using System;
using System.Collections.Generic;
using System.IO;
/// <summary>
/// A UI Package contains a description file and some texture, sound assets.
/// </summary>
public class UIPackage
{
    /// <summary>
    /// Package id. It is generated by the Editor.
    /// </summary>
    public string id { get; private set; }

    /// <summary>
    /// Package name.
    /// </summary>
    public string name { get; private set; }



    List<PackageItem> _items;
    Dictionary<string, PackageItem> _itemsById;
    Dictionary<string, PackageItem> _itemsByName;
    Dictionary<string, string>[] _dependencies;
    string _assetPath;
    string[] _branches;
    internal int _branchIndex;
    
    string _customId;
    bool _fromBundle;
   
    
    Dictionary<string, AtlasSprite> _sprites;
    public Dictionary<string, AtlasSprite> sprites { get { return _sprites; } }

    static Dictionary<string, UIPackage> _packageInstById = new Dictionary<string, UIPackage>();
    static Dictionary<string, UIPackage> _packageInstByName = new Dictionary<string, UIPackage>();
    static List<UIPackage> _packageList = new List<UIPackage>();
    static string _branch;

    internal static int _constructing;

    public const string URL_PREFIX = "ui://";

    public UIPackage()
    {
        _items = new List<PackageItem>();
        _itemsById = new Dictionary<string, PackageItem>();
        _itemsByName = new Dictionary<string, PackageItem>();
        _sprites = new Dictionary<string, AtlasSprite>();

        _branchIndex = -1;
    }


    /// <summary>
    /// Return a UIPackage with a certain id.
    /// </summary>
    /// <param name="id">ID of the package.</param>
    /// <returns>UIPackage</returns>
    public static UIPackage GetById(string id)
    {
        UIPackage pkg;
        if (_packageInstById.TryGetValue(id, out pkg))
            return pkg;
        else
            return null;
    }

    /// <summary>
    /// Return a UIPackage with a certain name.
    /// </summary>
    /// <param name="name">Name of the package.</param>
    /// <returns>UIPackage</returns>
    public static UIPackage GetByName(string name)
    {
        UIPackage pkg;
        if (_packageInstByName.TryGetValue(name, out pkg))
            return pkg;
        else
            return null;
    }


    /// <summary>
    /// Remove a package. All resources in this package will be disposed.
    /// </summary>
    /// <param name="packageIdOrName"></param>
    public static void RemovePackage(string packageIdOrName)
    {
        UIPackage pkg = null;
        if (!_packageInstById.TryGetValue(packageIdOrName, out pkg))
        {
            if (!_packageInstByName.TryGetValue(packageIdOrName, out pkg))
                throw new Exception("FairyGUI: '" + packageIdOrName + "' is not a valid package id or name.");
        }
        pkg.Dispose();
        _packageInstById.Remove(pkg.id);
        if (pkg._customId != null)
            _packageInstById.Remove(pkg._customId);
        if (pkg._assetPath != null)
            _packageInstById.Remove(pkg._assetPath);
        _packageInstByName.Remove(pkg.name);
        _packageList.Remove(pkg);
    }

    /// <summary>
    /// 
    /// </summary>
    public static void RemoveAllPackages()
    {
        if (_packageInstById.Count > 0)
        {
            UIPackage[] pkgs = _packageList.ToArray();

            foreach (UIPackage pkg in pkgs)
            {
                pkg.Dispose();
            }
        }
        _packageList.Clear();
        _packageInstById.Clear();
        _packageInstByName.Clear();
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    public static List<UIPackage> GetPackages()
    {
        return _packageList;
    }


    /// <summary>
    /// Get url of an item in package.
    /// </summary>
    /// <param name="pkgName">Package name.</param>
    /// <param name="resName">Resource name.</param>
    /// <returns>Url.</returns>
    public static string GetItemURL(string pkgName, string resName)
    {
        UIPackage pkg = GetByName(pkgName);
        if (pkg == null)
            return null;

        PackageItem pi;
        if (!pkg._itemsByName.TryGetValue(resName, out pi))
            return null;

        return URL_PREFIX + pkg.id + pi.id;
    }

    public static PackageItem GetItemByURL(string url)
    {
        if (url == null)
            return null;

        int pos1 = url.IndexOf("//");
        if (pos1 == -1)
            return null;

        int pos2 = url.IndexOf('/', pos1 + 2);
        if (pos2 == -1)
        {
            if (url.Length > 13)
            {
                string pkgId = url.Substring(5, 8);
                UIPackage pkg = GetById(pkgId);
                if (pkg != null)
                {
                    string srcId = url.Substring(13);
                    return pkg.GetItem(srcId);
                }
            }
        }
        else
        {
            string pkgName = url.Substring(pos1 + 2, pos2 - pos1 - 2);
            UIPackage pkg = GetByName(pkgName);
            if (pkg != null)
            {
                string srcName = url.Substring(pos2 + 1);
                return pkg.GetItemByName(srcName);
            }
        }

        return null;
    }

    /// <summary>
    /// 将'ui://包名/组件名'转换为以内部id表达的url格式。如果传入的url本身就是内部id格式，则直接返回。
    /// 同时这个方法还带格式检测，如果传入不正确的url，会返回null。
    /// </summary>
    /// <param name="url"></param>
    /// <returns></returns>
    public static string NormalizeURL(string url)
    {
        if (url == null)
            return null;

        int pos1 = url.IndexOf("//");
        if (pos1 == -1)
            return null;

        int pos2 = url.IndexOf('/', pos1 + 2);
        if (pos2 == -1)
            return url;
        else
        {
            string pkgName = url.Substring(pos1 + 2, pos2 - pos1 - 2);
            string srcName = url.Substring(pos2 + 1);
            return GetItemURL(pkgName, srcName);
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public string assetPath
    {
        get { return _assetPath; }
    }

    /// <summary>
    /// Set a custom id for package, then you can use it in GetById.
    /// </summary>
    public string customId
    {
        get { return _customId; }
        set
        {
            if (_customId != null)
                _packageInstById.Remove(_customId);
            _customId = value;
            if (_customId != null)
                _packageInstById[_customId] = this;
        }
    }


    /// <summary>
    /// 获得本包依赖的包的id列表
    /// </summary>
    public Dictionary<string, string>[] dependencies
    {
        get { return _dependencies; }
    }

    public bool LoadPackage(ByteBuffer buffer, string assetNamePrefix)
    {
        if (buffer.ReadUint() != 0x46475549)
        {
            throw new Exception("FairyGUI: old package format found in '" + assetNamePrefix + "'");
        }

        buffer.version = buffer.ReadInt();
        bool ver2 = buffer.version >= 2;
        buffer.ReadBool(); //compressed
        id = buffer.ReadString();
        name = buffer.ReadString();

        buffer.Skip(20);
        int indexTablePos = buffer.position;
        int cnt;

        buffer.Seek(indexTablePos, 4);

        cnt = buffer.ReadInt();
        string[] stringTable = new string[cnt];
        for (int i = 0; i < cnt; i++)
            stringTable[i] = buffer.ReadString();
        buffer.stringTable = stringTable;

        if (buffer.Seek(indexTablePos, 5))
        {
            cnt = buffer.ReadInt();
            for (int i = 0; i < cnt; i++)
            {
                int index = buffer.ReadUshort();
                int len = buffer.ReadInt();
                stringTable[index] = buffer.ReadString(len);
            }
        }

        buffer.Seek(indexTablePos, 0);

        cnt = buffer.ReadShort();
        _dependencies = new Dictionary<string, string>[cnt];
        for (int i = 0; i < cnt; i++)
        {
            Dictionary<string, string> kv = new Dictionary<string, string>();
            kv.Add("id", buffer.ReadS());
            kv.Add("name", buffer.ReadS());
            _dependencies[i] = kv;
        }

        bool branchIncluded = false;
        if (ver2)
        {
            cnt = buffer.ReadShort();
            if (cnt > 0)
            {
                _branches = buffer.ReadSArray(cnt);
                if (!string.IsNullOrEmpty(_branch))
                    _branchIndex = Array.IndexOf(_branches, _branch);
            }

            branchIncluded = cnt > 0;
        }

        buffer.Seek(indexTablePos, 1);

        PackageItem pi;
        string assetPath;
        if (assetNamePrefix.Length > 0)
        {
            assetPath = Path.GetDirectoryName(assetNamePrefix);
            if (assetPath.Length > 0)
                assetPath += "/";
            assetNamePrefix = assetNamePrefix + "_";
        }
        else
            assetPath = string.Empty;

        cnt = buffer.ReadShort();
        for (int i = 0; i < cnt; i++)
        {
            int nextPos = buffer.ReadInt();
            nextPos += buffer.position;

            pi = new PackageItem();
            pi.owner = this;
            pi.type = (PackageItemType)buffer.ReadByte();
            pi.id = buffer.ReadS();
            pi.name = buffer.ReadS();
            pi.path = buffer.ReadS(); //path
            pi.file = buffer.ReadS();
            pi.exported = buffer.ReadBool();
            pi.width = buffer.ReadInt();
            pi.height = buffer.ReadInt();

            switch (pi.type)
            {
                case PackageItemType.Image:
                    {
                        pi.objectType = ObjectType.Image;
                        int scaleOption = buffer.ReadByte();
                        if (scaleOption == 1)
                        {
                            Rect rect = new Rect();
                            rect.x = buffer.ReadInt();
                            rect.y = buffer.ReadInt();
                            rect.width = buffer.ReadInt();
                            rect.height = buffer.ReadInt();
                            pi.scale9Grid = rect;

                            pi.tileGridIndice = buffer.ReadInt();
                        }
                        else if (scaleOption == 2)
                            pi.scaleByTile = true;

                        buffer.ReadBool(); //smoothing
                        break;
                    }

                case PackageItemType.MovieClip:
                    {
                        buffer.ReadBool(); //smoothing
                        pi.objectType = ObjectType.MovieClip;
                        pi.rawData = buffer.ReadBuffer();
                        break;
                    }

                case PackageItemType.Font:
                    {
                        pi.rawData = buffer.ReadBuffer();
                        break;
                    }

                case PackageItemType.Atlas:
                case PackageItemType.Sound:
                case PackageItemType.Misc:
                    {
                        pi.file = assetNamePrefix + pi.file;
                        break;
                    }
            }

            if (ver2)
            {
                string str = buffer.ReadS();//branch
                if (str != null)
                    pi.name = str + "/" + pi.name;

                int branchCnt = buffer.ReadByte();
                if (branchCnt > 0)
                {
                    if (branchIncluded)
                        pi.branches = buffer.ReadSArray(branchCnt);
                    else
                        _itemsById[buffer.ReadS()] = pi;
                }

                int highResCnt = buffer.ReadByte();
                if (highResCnt > 0)
                    pi.highResolution = buffer.ReadSArray(highResCnt);
            }

            _items.Add(pi);
            _itemsById[pi.id] = pi;
            if (pi.name != null)
                _itemsByName[pi.name] = pi;

            buffer.position = nextPos;
        }

        buffer.Seek(indexTablePos, 2);

        cnt = buffer.ReadShort();
        for (int i = 0; i < cnt; i++)
        {
            int nextPos = buffer.ReadUshort();
            nextPos += buffer.position;

            string itemId = buffer.ReadS();
            pi = _itemsById[buffer.ReadS()];

            AtlasSprite sprite = new AtlasSprite();
            sprite.atlas = pi;
            sprite.rect.x = buffer.ReadInt();
            sprite.rect.y = buffer.ReadInt();
            sprite.rect.width = buffer.ReadInt();
            sprite.rect.height = buffer.ReadInt();
            sprite.rotated = buffer.ReadBool();
            if (ver2 && buffer.ReadBool())
            {
                sprite.offset.x = buffer.ReadInt();
                sprite.offset.y = buffer.ReadInt();
                sprite.originalSize.x = buffer.ReadInt();
                sprite.originalSize.y = buffer.ReadInt();
            }
            else if (sprite.rotated)
            {
                sprite.originalSize.x = sprite.rect.height;
                sprite.originalSize.y = sprite.rect.width;
            }
            else
            {
                sprite.originalSize.x = sprite.rect.width;
                sprite.originalSize.y = sprite.rect.height;
            }

            _sprites[itemId] = sprite;

            buffer.position = nextPos;
        }

        if (buffer.Seek(indexTablePos, 3))
        {
            cnt = buffer.ReadShort();
            for (int i = 0; i < cnt; i++)
            {
                int nextPos = buffer.ReadInt();
                nextPos += buffer.position;

                if (_itemsById.TryGetValue(buffer.ReadS(), out pi))
                {
                    if (pi.type == PackageItemType.Image)
                    {
                        pi.pixelHitTestData = new PixelHitTestData();
                        pi.pixelHitTestData.Load(buffer);
                    }
                }

                buffer.position = nextPos;
            }
        }

        _items.Sort(ComparePackageItem);

        return true;
    }

    static int ComparePackageItem(PackageItem p1, PackageItem p2)
    {
        if (p1.name != null && p2.name != null)
            return p1.name.CompareTo(p2.name);
        else
            return 0;
    }


    void Dispose()
    {
        int cnt = _items.Count;
        for (int i = 0; i < cnt; i++)
        {
            PackageItem pi = _items[i];
            if (pi.type == PackageItemType.Atlas)
            {
                
            }
            else if (pi.type == PackageItemType.Sound)
            {
                
            }
        }
        _items.Clear();

        
    }

    


    public List<PackageItem> GetItems()
    {
        return _items;
    }

    public PackageItem GetItem(string itemId)
    {
        PackageItem pi;
        if (_itemsById.TryGetValue(itemId, out pi))
            return pi;
        else
            return null;
    }

    public PackageItem GetItemByName(string itemName)
    {
        PackageItem pi;
        if (_itemsByName.TryGetValue(itemName, out pi))
            return pi;
        else
            return null;
    }



}